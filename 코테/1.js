// 도시에 n개의 전기 자전거 보관소가 있습니다. 각 보관소에는 0부터 n - 1까지 번호가 하나씩 붙어 있으며,
// 보관소 사이를 연결해주는 자전거 도로가 있습니다. 단, 아직 도로를 내는 중이라서 다른 보관소와 연결되지 않은 보관소가 있을 수 있습니다.
//  자전거 도로는 양방향 통행이 가능하며, 어느 방향으로 이동하든 걸리는 시간은 동일합니다. 전기 자전거 대여 시간은 k분이며,
// 대여 시간이 끝나면 즉시 자전거를 보관소에 반납해야 합니다. 이때 자전거는 아무 보관소에나 반납해도 됩니다.
// 당신은 0번 보관소에서 전기 자전거를 대여하여 자전거 도로를 따라 k분 동안 쉬지 않고 자전거를 탄 후,
// 대여시간이 끝나는 시각에 즉시 자전거를 반납할 수 있는 보관소는 어디인지 알아보려 합니다. 즉, 0번 보관소에서 출발하여 k분 동안 쉬지 않고 자전거를 탄 후,
// 대여 종료 시각에 정확히 도달할 수 있는 보관소를 찾아야 합니다. 이때, 한번 이용한 자전거 도로를 여러 번 이용하는 것은 가능하지만,
// 자전거 도로를 따라 달리다가 중간에 멈추거나 중간에서 방향을 바꾸어 되돌아 갈 수는 없습니다.
// 아래 그림은 각 보관소와 자전거 도로를 이용하는데 걸리는 시간을 나타낸 예시입니다.
// 위 그림에서 보관소는 총 6군데이며, 각각 0번부터 5번까지 번호를 가집니다. 이 예시에서 자전거 대여 시간은 17분이라고 가정합니다.

// 17분 후 1번 보관소에 도달하는 방법은 경로 0,1,2,1을 따르는 것입니다. 0번 보관소에서 1번 보관소까지 3분, 1번 보관소에서 2번 보관소까지 7분, 2번 보관소에서 1번 보관소까지 7분이 걸리므로 3+7+7=17분 후에 1번 보관소에서 자전거를 반납할 수 있습니다.

// 경로 0,4,0,4,5,2를 따라 2번 보관소에, 경로 0,4,0,1,2,3을 따라 3번 보관소에 정확히 17분 후에 도착해서 자전거를 반납할 수 있습니다. 0번, 4번, 5번 보관소에는 어떤 방법으로도 17분 후에 도착할 수 없습니다.

// 자전거 보관소의 수를 나타내는 정수 n, 자전거 대여시간을 나타내는 정수 k,
//각 지점을 연결하는 자전거 도로와 도로를 이용하는데 걸리는 시간을 나타내는 2차원 정수 배열 roads가 매개변수로 주어집니다.
//0번 보관소부터 자전거를 타기 시작했을 때, 쉬지 않고 k분 동안 자전거를 탄 뒤 도착할 수 있는 보관소의 번호를 배열에 담아
// 오름차순 정렬하여 return 하도록 solution 함수를 완성해주세요. 만약 조건을 만족하는 보관소가 없을 경우, -1을 배열에 담아 return 해주세요.

// 제한사항
// roads의 원소는 [a, b, t] 형식입니다.
// 보관소 a와 보관소 b를 직접 연결하는 길을 자전거를 타고 갈 때 걸리는 시간이 t임을 의미합니다.
// 같은 길이 중복하여 등장하지 않습니다.
// 0번 보관소는 항상 1개 이상의 다른 보관소와 연결되어 있습니다.
// 입출력 예
// n     k         roads      result
// 6    17    [[5, 4, 6], [5, 2, 5], [0, 4, 2], [2, 3, 3], [1, 2, 7], [0, 1, 3]]    [1, 2, 3]
// 4    10    [[0, 1, 2], [0, 2, 3]]    [0, 1]
// 4    11    [[0, 1, 2], [1, 2, 7], [2, 3, 10], [3, 0, 9]]    [-1]

///////// 나의풀이

//road그래프를 그린다.
// 그래프는 객체로 그리는게좋을듯 . [다음보관소, 걸리는시간]
// 로드돌면서 객체에 추가.

//내가 출발할 곳은 0번 보관소 .

//dfs [내가 있는 보관소, 지금시간]
//함수에 들어왔을때의 시간이 17이면 정답에 현재 보관소 추가
//17보다 크면 함수 리턴
// 17보다 작다면 현재 보관소의 연결되어있는 곳으로 다시 dfs (다음보관소,지금시간+다음보관소걸리는시간)

//0번 보관소부터 dfs시작.
//정답 정렬해서 리턴.
function solution(n, k, roads) {
  let road = {};
  for (let i = 0; i < n; i++) {
    road[i] = [];
  }

  roads.forEach((el, i) => {
    let [road1, road2, time] = el;
    road[road1].push([road2, time]);
    road[road2].push([road1, time]);
  });
  // [갈보관소,시간]
  let answer = new Set();
  function dfs(nowRoad, nowTime) {
    road[nowRoad].forEach(([nextRoad, nextTime]) => {
      if (nowTime + nextTime === k) {
        answer.add(nextRoad);
      } else if (nowTime + nextTime < k) {
        dfs(nextRoad, nowTime + nextTime);
      }
    });
  }
  dfs(0, 0);

  answer = Array.from(answer).sort((a, b) => a - b);
  return answer.length ? answer : [-1];
}

// 정답 [1, 2, 3]
console.log(
  solution(6, 17, [
    [5, 4, 6],
    [5, 2, 5],
    [0, 4, 2],
    [2, 3, 3],
    [1, 2, 7],
    [0, 1, 3],
  ])
);

//[0, 1]정답 (0,1)
console.log(
  solution(4, 10, [
    [0, 1, 2],
    [0, 2, 3],
  ])
);

//정답[-1]
console.log(
  solution(4, 11, [
    [0, 1, 2],
    [1, 2, 7],
    [2, 3, 10],
    [3, 0, 9],
  ])
);
